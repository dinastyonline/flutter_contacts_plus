// Autogenerated from Pigeon (v16.0.4), do not edit directly.
// See also: https://pub.dev/packages/pigeon

package com.dinastyonline.flutter_contacts_plus

import android.util.Log
import io.flutter.plugin.common.BasicMessageChannel
import io.flutter.plugin.common.BinaryMessenger
import io.flutter.plugin.common.MessageCodec
import io.flutter.plugin.common.StandardMessageCodec
import java.io.ByteArrayOutputStream
import java.nio.ByteBuffer

private fun wrapResult(result: Any?): List<Any?> {
  return listOf(result)
}

private fun wrapError(exception: Throwable): List<Any?> {
  if (exception is FlutterError) {
    return listOf(
      exception.code,
      exception.message,
      exception.details
    )
  } else {
    return listOf(
      exception.javaClass.simpleName,
      exception.toString(),
      "Cause: " + exception.cause + ", Stacktrace: " + Log.getStackTraceString(exception)
    )
  }
}

/**
 * Error class for passing custom error details to Flutter via a thrown PlatformException.
 * @property code The error code.
 * @property message The error message.
 * @property details The error details. Must be a datatype supported by the api codec.
 */
class FlutterError (
  val code: String,
  override val message: String? = null,
  val details: Any? = null
) : Throwable()

/** Generated class from Pigeon that represents data sent in messages. */
data class Name (
  val first: String,
  val last: String,
  val middle: String,
  val prefix: String,
  val suffix: String,
  val nickname: String,
  val firstPhonetic: String,
  val lastPhonetic: String,
  val middlePhonetic: String

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): Name {
      val first = list[0] as String
      val last = list[1] as String
      val middle = list[2] as String
      val prefix = list[3] as String
      val suffix = list[4] as String
      val nickname = list[5] as String
      val firstPhonetic = list[6] as String
      val lastPhonetic = list[7] as String
      val middlePhonetic = list[8] as String
      return Name(first, last, middle, prefix, suffix, nickname, firstPhonetic, lastPhonetic, middlePhonetic)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      first,
      last,
      middle,
      prefix,
      suffix,
      nickname,
      firstPhonetic,
      lastPhonetic,
      middlePhonetic,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class Phone (
  val number: String,
  val normalizedNumber: String,
  val label: String,
  val customLabel: String,
  val isPrimary: Boolean

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): Phone {
      val number = list[0] as String
      val normalizedNumber = list[1] as String
      val label = list[2] as String
      val customLabel = list[3] as String
      val isPrimary = list[4] as Boolean
      return Phone(number, normalizedNumber, label, customLabel, isPrimary)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      number,
      normalizedNumber,
      label,
      customLabel,
      isPrimary,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class Email (
  val address: String,
  val label: String,
  val customLabel: String,
  val isPrimary: Boolean

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): Email {
      val address = list[0] as String
      val label = list[1] as String
      val customLabel = list[2] as String
      val isPrimary = list[3] as Boolean
      return Email(address, label, customLabel, isPrimary)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      address,
      label,
      customLabel,
      isPrimary,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class Address (
  val address: String,
  val label: String,
  val customLabel: String,
  val street: String,
  val pobox: String,
  val neighborhood: String,
  val city: String,
  val state: String,
  val postalCode: String,
  val country: String,
  val isoCountry: String,
  val subAdminArea: String,
  val subLocality: String

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): Address {
      val address = list[0] as String
      val label = list[1] as String
      val customLabel = list[2] as String
      val street = list[3] as String
      val pobox = list[4] as String
      val neighborhood = list[5] as String
      val city = list[6] as String
      val state = list[7] as String
      val postalCode = list[8] as String
      val country = list[9] as String
      val isoCountry = list[10] as String
      val subAdminArea = list[11] as String
      val subLocality = list[12] as String
      return Address(address, label, customLabel, street, pobox, neighborhood, city, state, postalCode, country, isoCountry, subAdminArea, subLocality)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      address,
      label,
      customLabel,
      street,
      pobox,
      neighborhood,
      city,
      state,
      postalCode,
      country,
      isoCountry,
      subAdminArea,
      subLocality,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class Organization (
  val company: String,
  val title: String,
  val department: String,
  val jobDescription: String,
  val symbol: String,
  val phoneticName: String,
  val officeLocation: String

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): Organization {
      val company = list[0] as String
      val title = list[1] as String
      val department = list[2] as String
      val jobDescription = list[3] as String
      val symbol = list[4] as String
      val phoneticName = list[5] as String
      val officeLocation = list[6] as String
      return Organization(company, title, department, jobDescription, symbol, phoneticName, officeLocation)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      company,
      title,
      department,
      jobDescription,
      symbol,
      phoneticName,
      officeLocation,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class Website (
  val url: String,
  val label: String,
  val customLabel: String

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): Website {
      val url = list[0] as String
      val label = list[1] as String
      val customLabel = list[2] as String
      return Website(url, label, customLabel)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      url,
      label,
      customLabel,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class SocialMedia (
  val userName: String,
  val label: String,
  val customLabel: String

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): SocialMedia {
      val userName = list[0] as String
      val label = list[1] as String
      val customLabel = list[2] as String
      return SocialMedia(userName, label, customLabel)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      userName,
      label,
      customLabel,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class Event (
  val year: Long? = null,
  val month: Long,
  val day: Long,
  val label: String,
  val customLabel: String

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): Event {
      val year = list[0].let { if (it is Int) it.toLong() else it as Long? }
      val month = list[1].let { if (it is Int) it.toLong() else it as Long }
      val day = list[2].let { if (it is Int) it.toLong() else it as Long }
      val label = list[3] as String
      val customLabel = list[4] as String
      return Event(year, month, day, label, customLabel)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      year,
      month,
      day,
      label,
      customLabel,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class Note (
  val note: String

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): Note {
      val note = list[0] as String
      return Note(note)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      note,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class Account (
  val rawId: String,
  val name: String,
  val type: String,
  val mimetypes: List<String?>

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): Account {
      val rawId = list[0] as String
      val name = list[1] as String
      val type = list[2] as String
      val mimetypes = list[3] as List<String?>
      return Account(rawId, name, type, mimetypes)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      rawId,
      name,
      type,
      mimetypes,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class Group (
  val id: String,
  val name: String

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): Group {
      val id = list[0] as String
      val name = list[1] as String
      return Group(id, name)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      id,
      name,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class Contact (
  val id: String,
  val displayName: String,
  val isStarred: Boolean,
  val name: Name? = null,
  val thumbnail: ByteArray? = null,
  val photo: ByteArray? = null,
  val phones: List<Phone?>,
  val emails: List<Email?>,
  val addresses: List<Address?>,
  val organizations: List<Organization?>,
  val websites: List<Website?>,
  val socialMedias: List<SocialMedia?>,
  val events: List<Event?>,
  val notes: List<Note?>,
  val accounts: List<Account?>,
  val groups: List<Group?>

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): Contact {
      val id = list[0] as String
      val displayName = list[1] as String
      val isStarred = list[2] as Boolean
      val name: Name? = (list[3] as List<Any?>?)?.let {
        Name.fromList(it)
      }
      val thumbnail = list[4] as ByteArray?
      val photo = list[5] as ByteArray?
      val phones = list[6] as List<Phone?>
      val emails = list[7] as List<Email?>
      val addresses = list[8] as List<Address?>
      val organizations = list[9] as List<Organization?>
      val websites = list[10] as List<Website?>
      val socialMedias = list[11] as List<SocialMedia?>
      val events = list[12] as List<Event?>
      val notes = list[13] as List<Note?>
      val accounts = list[14] as List<Account?>
      val groups = list[15] as List<Group?>
      return Contact(id, displayName, isStarred, name, thumbnail, photo, phones, emails, addresses, organizations, websites, socialMedias, events, notes, accounts, groups)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      id,
      displayName,
      isStarred,
      name?.toList(),
      thumbnail,
      photo,
      phones,
      emails,
      addresses,
      organizations,
      websites,
      socialMedias,
      events,
      notes,
      accounts,
      groups,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class ContactsRequest (
  val withProperties: Boolean,
  val withThumbnail: Boolean,
  val withPhoto: Boolean,
  val withGroups: Boolean,
  val withAccounts: Boolean,
  val returnUnifiedContacts: Boolean,
  val includeNotesOnIos13AndAbove: Boolean

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): ContactsRequest {
      val withProperties = list[0] as Boolean
      val withThumbnail = list[1] as Boolean
      val withPhoto = list[2] as Boolean
      val withGroups = list[3] as Boolean
      val withAccounts = list[4] as Boolean
      val returnUnifiedContacts = list[5] as Boolean
      val includeNotesOnIos13AndAbove = list[6] as Boolean
      return ContactsRequest(withProperties, withThumbnail, withPhoto, withGroups, withAccounts, returnUnifiedContacts, includeNotesOnIos13AndAbove)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      withProperties,
      withThumbnail,
      withPhoto,
      withGroups,
      withAccounts,
      returnUnifiedContacts,
      includeNotesOnIos13AndAbove,
    )
  }
}

@Suppress("UNCHECKED_CAST")
private object ContactsHostApiCodec : StandardMessageCodec() {
  override fun readValueOfType(type: Byte, buffer: ByteBuffer): Any? {
    return when (type) {
      128.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          Account.fromList(it)
        }
      }
      129.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          Address.fromList(it)
        }
      }
      130.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          Contact.fromList(it)
        }
      }
      131.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          ContactsRequest.fromList(it)
        }
      }
      132.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          Email.fromList(it)
        }
      }
      133.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          Event.fromList(it)
        }
      }
      134.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          Group.fromList(it)
        }
      }
      135.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          Name.fromList(it)
        }
      }
      136.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          Note.fromList(it)
        }
      }
      137.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          Organization.fromList(it)
        }
      }
      138.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          Phone.fromList(it)
        }
      }
      139.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          SocialMedia.fromList(it)
        }
      }
      140.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          Website.fromList(it)
        }
      }
      else -> super.readValueOfType(type, buffer)
    }
  }
  override fun writeValue(stream: ByteArrayOutputStream, value: Any?)   {
    when (value) {
      is Account -> {
        stream.write(128)
        writeValue(stream, value.toList())
      }
      is Address -> {
        stream.write(129)
        writeValue(stream, value.toList())
      }
      is Contact -> {
        stream.write(130)
        writeValue(stream, value.toList())
      }
      is ContactsRequest -> {
        stream.write(131)
        writeValue(stream, value.toList())
      }
      is Email -> {
        stream.write(132)
        writeValue(stream, value.toList())
      }
      is Event -> {
        stream.write(133)
        writeValue(stream, value.toList())
      }
      is Group -> {
        stream.write(134)
        writeValue(stream, value.toList())
      }
      is Name -> {
        stream.write(135)
        writeValue(stream, value.toList())
      }
      is Note -> {
        stream.write(136)
        writeValue(stream, value.toList())
      }
      is Organization -> {
        stream.write(137)
        writeValue(stream, value.toList())
      }
      is Phone -> {
        stream.write(138)
        writeValue(stream, value.toList())
      }
      is SocialMedia -> {
        stream.write(139)
        writeValue(stream, value.toList())
      }
      is Website -> {
        stream.write(140)
        writeValue(stream, value.toList())
      }
      else -> super.writeValue(stream, value)
    }
  }
}

/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface ContactsHostApi {
  fun getContacts(config: ContactsRequest, callback: (Result<List<Contact>>) -> Unit)
  fun getContactsWithName(name: String, config: ContactsRequest, callback: (Result<List<Contact>>) -> Unit)
  fun getContactsWithEmail(email: String, config: ContactsRequest, callback: (Result<List<Contact>>) -> Unit)
  fun getContactsWithPhone(phone: String, config: ContactsRequest, callback: (Result<List<Contact>>) -> Unit)
  fun getContactsWithIds(ids: List<String>, config: ContactsRequest, callback: (Result<List<Contact>>) -> Unit)
  fun getContactsInGroup(groupId: String, config: ContactsRequest, callback: (Result<List<Contact>>) -> Unit)
  fun getContactsInContainer(containerId: String, config: ContactsRequest, callback: (Result<List<Contact>>) -> Unit)
  fun checkPermission(callback: (Result<String>) -> Unit)
  fun requestPermission(callback: (Result<Boolean>) -> Unit)

  companion object {
    /** The codec used by ContactsHostApi. */
    val codec: MessageCodec<Any?> by lazy {
      ContactsHostApiCodec
    }
    /** Sets up an instance of `ContactsHostApi` to handle messages through the `binaryMessenger`. */
    @Suppress("UNCHECKED_CAST")
    fun setUp(binaryMessenger: BinaryMessenger, api: ContactsHostApi?) {
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.com.dinastyonline.flutter_contacts_plus.ContactsHostApi.getContacts", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val configArg = args[0] as ContactsRequest
            api.getContacts(configArg) { result: Result<List<Contact>> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.com.dinastyonline.flutter_contacts_plus.ContactsHostApi.getContactsWithName", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val nameArg = args[0] as String
            val configArg = args[1] as ContactsRequest
            api.getContactsWithName(nameArg, configArg) { result: Result<List<Contact>> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.com.dinastyonline.flutter_contacts_plus.ContactsHostApi.getContactsWithEmail", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val emailArg = args[0] as String
            val configArg = args[1] as ContactsRequest
            api.getContactsWithEmail(emailArg, configArg) { result: Result<List<Contact>> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.com.dinastyonline.flutter_contacts_plus.ContactsHostApi.getContactsWithPhone", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val phoneArg = args[0] as String
            val configArg = args[1] as ContactsRequest
            api.getContactsWithPhone(phoneArg, configArg) { result: Result<List<Contact>> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.com.dinastyonline.flutter_contacts_plus.ContactsHostApi.getContactsWithIds", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val idsArg = args[0] as List<String>
            val configArg = args[1] as ContactsRequest
            api.getContactsWithIds(idsArg, configArg) { result: Result<List<Contact>> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.com.dinastyonline.flutter_contacts_plus.ContactsHostApi.getContactsInGroup", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val groupIdArg = args[0] as String
            val configArg = args[1] as ContactsRequest
            api.getContactsInGroup(groupIdArg, configArg) { result: Result<List<Contact>> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.com.dinastyonline.flutter_contacts_plus.ContactsHostApi.getContactsInContainer", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val containerIdArg = args[0] as String
            val configArg = args[1] as ContactsRequest
            api.getContactsInContainer(containerIdArg, configArg) { result: Result<List<Contact>> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.com.dinastyonline.flutter_contacts_plus.ContactsHostApi.checkPermission", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.checkPermission() { result: Result<String> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.com.dinastyonline.flutter_contacts_plus.ContactsHostApi.requestPermission", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.requestPermission() { result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
